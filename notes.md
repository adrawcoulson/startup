// Source Control three dots is where push and pull commands are located
// In merge conflicts,  select 'Accept Current, Incoming, or Both' changes option menu found about differences
ssh -i ~/Downloads/production.pem ubuntu@52.22.1.162

**Amazon Web Servics**
- My IP address is 52.22.1.162
- Command to remote shell into my server is ssh -i ~/Downloads/production.pem ubuntu@3.83.118.14
**HTML Beginnings**
  - <a href = "URL"> a is for anchor, href is for hyperlink reference
  - <img scr = "URL.jpg"> to connect images
  - always close HTML line with </repeat of initial command>
**HTML Media**
- HTML youtube videos. Share > Embed > Copy code
- HTML Image. Add file to GitHub, copy image address
**Javascript**
- Coding is weak, can be reassigned types
** Connecting .css
- "" are object {} in.css
** Web Services Notes
  - URL(Uniform Resource Locator), formatted as such: <scheme>://<domain name>:<port>/<path>?<parameters>#<anchor>, EX. https://byu.edu:443/cs/260/student?filter=accepted#summary
  - Ports connect devices to internet with help of IP address. Our web services uses port 22, 443, 80. 0-1023 used for general purposes. 1023 + for individual use
  - 20	File Transfer Protocol (FTP) for data transfer
  - 22	Secure Shell (SSH) for connecting to remote devices
  - 25	Simple Mail Transfer Protocol (SMTP) for sending email
  - 53	Domain Name System (DNS) for looking up IP addresses
  - 80	Hypertext Transfer Protocol (HTTP) for web requests
  - 110	Post Office Protocol (POP3) for retrieving email
  - 123	Network Time Protocol (NTP) for managing time
  - 161	Simple Network Management Protocol (SNMP) for managing network devices such as routers or printers
  - 194	Internet Relay Chat (IRC) for chatting
  - 443	HTTP Secure (HTTPS) for secure web requests
**HTTPS
  - Request: <verb> <url path, parameters, anchor> <version>[<header key: value>]*[<body>]
  - Response: <version> <status code> <status string>[<header key: value>]*[<body>]
  - GET, POST(create), PUT(update), DELETE, OPTIONS(metadata)
  - HTTP headers specify metadata about a request or response
  - Request does not know anything about a previous or future request. Cookies are generated by a server and passed to the client as an HTTP header. The client then caches the cookie and returns it as an HTTP header back to the server on subsequent requests.This allows the server to rem ember things like the language preference of the user
**SOP and CORS
  - Same Origin Policy: only allows Jav
  - aScript to make requests to a domain if it is the same domain that the user is currently viewing
  - Cross Origin Response Sharing:allows the client (e.g. browser) to specify the origin of a request and then let the server respond with what origins are allowed.
  - Using 3rd Party Services: if you want to make requests to a different domain than the one your web application is hosted on, then you need to make sure that domain allows requests as defined by the Access-Control-Allow-Origin header it returns.
***Fetch
  - make HTTP requests from JavaScript
  - The basic usage of fetch takes a URL and returns a promise. The promise then function takes a callback function that is asynchronously called when the requested URL content is obtained. If the returned content is of type application/json you can use the json function on the response object to convert it to a JavaScript object.


**What ports are used for HTTP, HTTPS, SSH?**
  - HTTP typically uses port 80, HTTPS uses port 443, and SSH uses port 22.
    
**What do HTTP status codes in the 300, 400, 500 range indicate?**
  - 300 range generally indicate redirection, 400 range indicate client errors,  500 range indicate server errors
    
**What does the HTTP header content-type allows you to do?**
  - specify the type of content that is being sent in the body of an HTTP request or response. It tells the recipient how the content is encoded or what the media type is so that the recipient can properly interpret and handle the content.
    
  - For example, if you set Content-Type: application/json in the header, it indicates that the content of the HTTP message body is in JSON format. Similarly, Content-Type: text/html specifies that the content is HTML.

**What do the following attributes of a cookie do? •	Domain •	Path •	SameSite •	HTTPOnly**
  - Domain: Specifies the domain for which the cookie is valid. Cookies are typically sent to the domain they originated from and any subdomains. For example, a cookie set for .example.com would be sent to example.com as well as subdomain.example.com.

  - Path: Defines the URL path for which the cookie is valid. If a cookie is set with a specific path, it will be sent only to that path and its subdirectories. For instance, a cookie set for /products will be sent to URLs like /products/item1, /products/item2, etc.

  - SameSite: This attribute is a relatively newer addition to cookies and is used to prevent cross-site request forgery attacks. It defines whether a cookie should be sent with cross-origin requests. SameSite=Strict allows cookies to be sent only in a first-party context (requests initiated by the same site). SameSite=Lax allows some cross-site context, for example, a link clicked from an external site. SameSite=None allows cross-origin sharing, but it requires the Secure attribute (secure context, usually over HTTPS).

  - HttpOnly: When this attribute is set, it prevents the cookie from being accessed by JavaScript. It helps mitigate certain types of cross-site scripting (XSS) attacks by ensuring that the cookie is only accessible via HTTP(S) requests and not through client-side scripts.

**Assuming the following Express middleware, what would be the console.log output for an HTTP GET request with a URL path of /foo/bar?**

  - app.use('/foo', (req, res, next) => {
  console.log('Middleware for /foo');
  next();
});

  - app.use('/foo/bar', (req, res, next) => {
  console.log('Middleware for /foo/bar');
  next();
});

  - Middleware for /foo
  - Middleware for /foo/bar
  - This assumes that app refers to an instance of Express, and these middleware functions are registered in sequence using app.use(). The first middleware is triggered because it matches the /foo path, and the second middleware is triggered because it matches the more specific /foo/bar path.

**Given the following Express service code: What does the following JavaScript fetch return?**
  - This code uses fetch to send a GET request to https://api.example.com/data. When the server responds with data, the first .then block checks if the response is okay (status code 200-299). If the response is okay, it parses the response body as JSON. Then, in the second .then block, it logs the parsed JSON data to the console.

  - If any errors occur during the fetch (e.g., network issues, server errors), the .catch block will handle them, logging the error to the console.

**Given the following MongoDB query { cost: { $gt: 10 }, name: /fran.*/} select all of the matching documents.**
  - Cost: It looks for documents where the cost field is greater than ($gt) 10.
  - Name: It looks for documents where the name field matches a regular expression (/fran.*/). This regex matches any string that starts with "fran" and is followed by any characters.

**How should you store user passwords in a database?**
  - Salt Hashmapping

**Assuming the following Node.js service code is executing with websockets, what will be logged to the console of the web browser?**
  - assuming there's an event listener for WebSocket messages in the client-side JavaScript,const socket = new WebSocket('ws://example.com'); // Replace 'example.com' with your server URL

  - socket.addEventListener('message', event => {
  console.log('Message from server:', event.data);});

**10.	What is the WebSocket protocol used for?**
  - provides a persistent connection between a client and a server, allowing for real-time, bidirectional communication.
  - : WebSocket connections have lower overhead compared to HTTP, reducing the latency involved in establishing and maintaining connections. This makes WebSockets particularly suitable for real-time applications where immediate data transmission is crucial,
  - Once established, the WebSocket connection remains open, allowing for efficient and instant communication without the need for repeated connection setups (as in traditional HTTP connections).

**11.	What is JSX and how are the curly braces rendered?**
  - JSX (JavaScript XML) is a syntax extension for JavaScript, commonly associated with React, that allows developers to write HTML-like code within JavaScript. It simplifies the creation of UI components by blending HTML structures with JavaScript functionality.

  - When working with JSX, curly braces {} are used to embed JavaScript expressions or values within the JSX syntax. This enables dynamic content, variable interpolation, function calls, and conditional rendering directly within the JSX code.

  - const name = 'John Doe';
const greeting = <p>Hello, {name}!</p>;

  - ReactDOM.render(
  greeting,
  document.getElementById('root')
);

  - {name} within the JSX tags represents a JavaScript expression, allowing the name variable's value ('John Doe') to be rendered within the <p> element.
The curly braces signal that the content inside them should be interpreted as JavaScript code.

**12.	Assuming a HTML document with a**
**<div id="root"></div>**
**element, what content will the following React component generate?
      function Welcome(props) {
        return <h1>Hello, {props.name}</h1>;
      }
      function App() {
        return (
          <div>
            <Welcome name="Sara" />
            <Welcome name="Cahal" />
            <Welcome name="Edite" />
          </div>
        );
      }
      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);**
      

  - The provided React code creates a simple Welcome component that accepts a name prop and returns an <h1> element displaying a greeting.

  - The App component then renders multiple instances of the Welcome component, passing different names as props.

  - Finally, it renders the App component into the HTML element with the ID of 'root'.

  - Based on the provided React code, when executed, the content generated in the HTML element with the ID 'root' will be:

**1.	Assuming a HTML document with a**
**<div id="root"></div>**
**element, what content will the following React component generate?
    function Numbers() { 
      const numbers = [1, 2, 3, 4, 5];
      const listItems = numbers.map((number) =>
        <li>{number}</li>
      );
      return(<ul>{listItems}</ul>)
    }
    const root = ReactDOM.createRoot(document.getElementById('root')); 
    root.render(<Numbers/>);**
    
  - The provided React code defines a Numbers component that creates an unordered list (<ul>) containing list items (<li>) based on an array of numbers.

  - The Numbers component generates an unordered list (<ul>) containing list items (<li>) for each number in the numbers array. Each list item displays the number itself.

  - When rendered into the HTML element with the ID 'root', the content generated will be:
  - <div id="root">
  - <ul>
  - <li>1</li>
  - <li>2</li>
  - <li>3</li>
  - <li>4</li>
  - <li>5</li>
  - </ul>
  - </div>

**14.	What does the following React component do?**
15.	function Example() {
16.	  // Declare a new state variable, which we'll call "count"  
  const [count, setCount] = useState(0);
17.	  return (
18.	    <div>
19.	      <p>You clicked {count} times</p>
20.	      <button onClick={() => setCount(count + 1)}>
21.	        Click me
22.	      </button>
23.	    </div>
24.	  );

  - Line 15: The Example function is declared, which represents a React functional component.
  - Line 16: Within the Example component, a state variable called count is declared using the useState hook. useState(0) initializes count with an initial value of 0. The useState hook returns an array with two elements: the current state value (count) and a function (setCount) to update that state value.
  - Line 17-23: The return statement contains JSX, defining the UI elements that will be rendered. In this case, it's a div containing a paragraph (<p>) and a button (<button>).
  - Line 19: Displays a paragraph (<p>) with the text "You clicked {count} times". The curly braces {count} allow the count state variable to be dynamically displayed in the text.
  - Line 20-22: Defines a button (<button>) element with the text "Click me". It also sets an onClick event handler. When the button is clicked, the setCount function is invoked. This function updates the count state by incrementing its current value by 1 (count + 1).

**25.	What are React Hooks used for?**
  - introduce state and side effects in functional components. Before Hooks were introduced, functional components in React were stateless and couldn't manage their own state or use lifecycle methods.
  - useState allow functional components to have their own local state
  - useEffect replicate lifecycle behavior (such as component mounting, updating, and unmounting) and allow performing side effects (e.g., data fetching, subscriptions, DOM manipulations) within functional components.
  - Hooks optimize the performance of functional components by enabling the use of React.memo and other performance optimization techniques, avoiding unnecessary re-renders.

**26.	What is the useEffect hook used for?**
  - perform side effects in functional components. Side effects refer to any code that interacts with the outside world, such as fetching data, subscriptions, manually changing the DOM, or setting up timers.
  - Replicating Lifecycle Methods: It combines the functionality of componentDidMount, componentDidUpdate, and componentWillUnmount in class-based components. The effect runs after every completed render, but you can control when it runs by specifying dependencies.
  - Managing Subscription and Cleanup: useEffect returns a cleanup function, which allows you to clean up any subscriptions, event listeners, or other resources created within the effect. This helps prevent memory leaks and ensures proper cleanup when the component is unmounted.

