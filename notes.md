// Source Control three dots is where push and pull commands are located
// In merge conflicts,  select 'Accept Current, Incoming, or Both' changes option menu found about differences
ssh -i ~/Downloads/production.pem ubuntu@52.22.1.162

**Amazon Web Servics**
- My IP address is 52.22.1.162
- Command to remote shell into my server is ssh -i ~/Downloads/production.pem ubuntu@3.83.118.14
**HTML Beginnings**
  - <a href = "URL"> a is for anchor, href is for hyperlink reference
  - <img scr = "URL.jpg"> to connect images
  - always close HTML line with </repeat of initial command>
**HTML Media**
- HTML youtube videos. Share > Embed > Copy code
- HTML Image. Add file to GitHub, copy image address
**Javascript**
- Coding is weak, can be reassigned types
** Connecting .css
- "" are object {} in.css
** Web Services Notes
  - URL(Uniform Resource Locator), formatted as such: <scheme>://<domain name>:<port>/<path>?<parameters>#<anchor>, EX. https://byu.edu:443/cs/260/student?filter=accepted#summary
  - Ports connect devices to internet with help of IP address. Our web services uses port 22, 443, 80. 0-1023 used for general purposes. 1023 + for individual use
  - 20	File Transfer Protocol (FTP) for data transfer
  - 22	Secure Shell (SSH) for connecting to remote devices
  - 25	Simple Mail Transfer Protocol (SMTP) for sending email
  - 53	Domain Name System (DNS) for looking up IP addresses
  - 80	Hypertext Transfer Protocol (HTTP) for web requests
  - 110	Post Office Protocol (POP3) for retrieving email
  - 123	Network Time Protocol (NTP) for managing time
  - 161	Simple Network Management Protocol (SNMP) for managing network devices such as routers or printers
  - 194	Internet Relay Chat (IRC) for chatting
  - 443	HTTP Secure (HTTPS) for secure web requests
**HTTPS
  - Request: <verb> <url path, parameters, anchor> <version>[<header key: value>]*[<body>]
  - Response: <version> <status code> <status string>[<header key: value>]*[<body>]
  - GET, POST(create), PUT(update), DELETE, OPTIONS(metadata)
  - HTTP headers specify metadata about a request or response
  - Request does not know anything about a previous or future request. Cookies are generated by a server and passed to the client as an HTTP header. The client then caches the cookie and returns it as an HTTP header back to the server on subsequent requests.This allows the server to rem ember things like the language preference of the user
**SOP and CORS
  - Same Origin Policy: only allows Jav
  - aScript to make requests to a domain if it is the same domain that the user is currently viewing
  - Cross Origin Response Sharing:allows the client (e.g. browser) to specify the origin of a request and then let the server respond with what origins are allowed.
  - Using 3rd Party Services: if you want to make requests to a different domain than the one your web application is hosted on, then you need to make sure that domain allows requests as defined by the Access-Control-Allow-Origin header it returns.
***Fetch
  - make HTTP requests from JavaScript
  - The basic usage of fetch takes a URL and returns a promise. The promise then function takes a callback function that is asynchronously called when the requested URL content is obtained. If the returned content is of type application/json you can use the json function on the response object to convert it to a JavaScript object.


**What ports are used for HTTP, HTTPS, SSH?**
  - HTTP typically uses port 80, HTTPS uses port 443, and SSH uses port 22.
    
**What do HTTP status codes in the 300, 400, 500 range indicate?**
  - 300 range generally indicate redirection, 400 range indicate client errors,  500 range indicate server errors
    
**What does the HTTP header content-type allows you to do?**
  - specify the type of content that is being sent in the body of an HTTP request or response. It tells the recipient how the content is encoded or what the media type is so that the recipient can properly interpret and handle the content.
    
  - For example, if you set Content-Type: application/json in the header, it indicates that the content of the HTTP message body is in JSON format. Similarly, Content-Type: text/html specifies that the content is HTML.

**What do the following attributes of a cookie do? •	Domain •	Path •	SameSite •	HTTPOnly**
  - Domain: Specifies the domain for which the cookie is valid. Cookies are typically sent to the domain they originated from and any subdomains. For example, a cookie set for .example.com would be sent to example.com as well as subdomain.example.com.

  - Path: Defines the URL path for which the cookie is valid. If a cookie is set with a specific path, it will be sent only to that path and its subdirectories. For instance, a cookie set for /products will be sent to URLs like /products/item1, /products/item2, etc.

  - SameSite: This attribute is a relatively newer addition to cookies and is used to prevent cross-site request forgery attacks. It defines whether a cookie should be sent with cross-origin requests. SameSite=Strict allows cookies to be sent only in a first-party context (requests initiated by the same site). SameSite=Lax allows some cross-site context, for example, a link clicked from an external site. SameSite=None allows cross-origin sharing, but it requires the Secure attribute (secure context, usually over HTTPS).

  - HttpOnly: When this attribute is set, it prevents the cookie from being accessed by JavaScript. It helps mitigate certain types of cross-site scripting (XSS) attacks by ensuring that the cookie is only accessible via HTTP(S) requests and not through client-side scripts.

**Assuming the following Express middleware, what would be the console.log output for an HTTP GET request with a URL path of /foo/bar?**

  - app.use('/foo', (req, res, next) => {
  console.log('Middleware for /foo');
  next();
});

  - app.use('/foo/bar', (req, res, next) => {
  console.log('Middleware for /foo/bar');
  next();
});

  - Middleware for /foo
  - Middleware for /foo/bar
  - This assumes that app refers to an instance of Express, and these middleware functions are registered in sequence using app.use(). The first middleware is triggered because it matches the /foo path, and the second middleware is triggered because it matches the more specific /foo/bar path.

**Given the following Express service code: What does the following JavaScript fetch return?**
  - This code uses fetch to send a GET request to https://api.example.com/data. When the server responds with data, the first .then block checks if the response is okay (status code 200-299). If the response is okay, it parses the response body as JSON. Then, in the second .then block, it logs the parsed JSON data to the console.

  - If any errors occur during the fetch (e.g., network issues, server errors), the .catch block will handle them, logging the error to the console.

**Given the following MongoDB query { cost: { $gt: 10 }, name: /fran.*/} select all of the matching documents.**
  - Cost: It looks for documents where the cost field is greater than ($gt) 10.
  - Name: It looks for documents where the name field matches a regular expression (/fran.*/). This regex matches any string that starts with "fran" and is followed by any characters.

**How should you store user passwords in a database?**
  - Salt Hashmapping

**Assuming the following Node.js service code is executing with websockets, what will be logged to the console of the web browser?**
  - assuming there's an event listener for WebSocket messages in the client-side JavaScript,const socket = new WebSocket('ws://example.com'); // Replace 'example.com' with your server URL

  - socket.addEventListener('message', event => {
  console.log('Message from server:', event.data);});

**10.	What is the WebSocket protocol used for?**
  - provides a persistent connection between a client and a server, allowing for real-time, bidirectional communication.
  - : WebSocket connections have lower overhead compared to HTTP, reducing the latency involved in establishing and maintaining connections. This makes WebSockets particularly suitable for real-time applications where immediate data transmission is crucial,
  - Once established, the WebSocket connection remains open, allowing for efficient and instant communication without the need for repeated connection setups (as in traditional HTTP connections).

**11.	What is JSX and how are the curly braces rendered?**
  - JSX (JavaScript XML) is a syntax extension for JavaScript, commonly associated with React, that allows developers to write HTML-like code within JavaScript. It simplifies the creation of UI components by blending HTML structures with JavaScript functionality.

  - When working with JSX, curly braces {} are used to embed JavaScript expressions or values within the JSX syntax. This enables dynamic content, variable interpolation, function calls, and conditional rendering directly within the JSX code.

  - const name = 'John Doe';
const greeting = <p>Hello, {name}!</p>;

  - ReactDOM.render(
  greeting,
  document.getElementById('root')
);

  - {name} within the JSX tags represents a JavaScript expression, allowing the name variable's value ('John Doe') to be rendered within the <p> element.
The curly braces signal that the content inside them should be interpreted as JavaScript code.

**12.	Assuming a HTML document with a**
**<div id="root"></div>**
**element, what content will the following React component generate?
      function Welcome(props) {
        return <h1>Hello, {props.name}</h1>;
      }
      function App() {
        return (
          <div>
            <Welcome name="Sara" />
            <Welcome name="Cahal" />
            <Welcome name="Edite" />
          </div>
        );
      }
      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);**
      

  - The provided React code creates a simple Welcome component that accepts a name prop and returns an <h1> element displaying a greeting.

  - The App component then renders multiple instances of the Welcome component, passing different names as props.

  - Finally, it renders the App component into the HTML element with the ID of 'root'.

  - Based on the provided React code, when executed, the content generated in the HTML element with the ID 'root' will be:

**1.	Assuming a HTML document with a**
**<div id="root"></div>**
**element, what content will the following React component generate?
    function Numbers() { 
      const numbers = [1, 2, 3, 4, 5];
      const listItems = numbers.map((number) =>
        <li>{number}</li>
      );
      return(<ul>{listItems}</ul>)
    }
    const root = ReactDOM.createRoot(document.getElementById('root')); 
    root.render(<Numbers/>);**
    
  - The provided React code defines a Numbers component that creates an unordered list (<ul>) containing list items (<li>) based on an array of numbers.

  - The Numbers component generates an unordered list (<ul>) containing list items (<li>) for each number in the numbers array. Each list item displays the number itself.

  - When rendered into the HTML element with the ID 'root', the content generated will be:
  - <div id="root">
  - <ul>
  - <li>1</li>
  - <li>2</li>
  - <li>3</li>
  - <li>4</li>
  - <li>5</li>
  - </ul>
  - </div>

**14.	What does the following React component do?**
15.	function Example() {
16.	  // Declare a new state variable, which we'll call "count"  
  const [count, setCount] = useState(0);
17.	  return (
18.	    <div>
19.	      <p>You clicked {count} times</p>
20.	      <button onClick={() => setCount(count + 1)}>
21.	        Click me
22.	      </button>
23.	    </div>
24.	  );

  - Line 15: The Example function is declared, which represents a React functional component.
  - Line 16: Within the Example component, a state variable called count is declared using the useState hook. useState(0) initializes count with an initial value of 0. The useState hook returns an array with two elements: the current state value (count) and a function (setCount) to update that state value.
  - Line 17-23: The return statement contains JSX, defining the UI elements that will be rendered. In this case, it's a div containing a paragraph (<p>) and a button (<button>).
  - Line 19: Displays a paragraph (<p>) with the text "You clicked {count} times". The curly braces {count} allow the count state variable to be dynamically displayed in the text.
  - Line 20-22: Defines a button (<button>) element with the text "Click me". It also sets an onClick event handler. When the button is clicked, the setCount function is invoked. This function updates the count state by incrementing its current value by 1 (count + 1).

**25.	What are React Hooks used for?**
  - introduce state and side effects in functional components. Before Hooks were introduced, functional components in React were stateless and couldn't manage their own state or use lifecycle methods.
  - useState allow functional components to have their own local state
  - useEffect replicate lifecycle behavior (such as component mounting, updating, and unmounting) and allow performing side effects (e.g., data fetching, subscriptions, DOM manipulations) within functional components.
  - Hooks optimize the performance of functional components by enabling the use of React.memo and other performance optimization techniques, avoiding unnecessary re-renders.

**26.	What is the useEffect hook used for?**
  - perform side effects in functional components. Side effects refer to any code that interacts with the outside world, such as fetching data, subscriptions, manually changing the DOM, or setting up timers.
  - Replicating Lifecycle Methods: It combines the functionality of componentDidMount, componentDidUpdate, and componentWillUnmount in class-based components. The effect runs after every completed render, but you can control when it runs by specifying dependencies.
  - Managing Subscription and Cleanup: useEffect returns a cleanup function, which allows you to clean up any subscriptions, event listeners, or other resources created within the effect. This helps prevent memory leaks and ensures proper cleanup when the component is unmounted.

**27.	What does this code do?**
28.	export default function App() {
29.	  return (
30.	    <BrowserRouter>
31.	      <Routes>
32.	        <Route path="/" element={<Layout />}>
33.	          <Route index element={<Home />} />
34.	          <Route path="blogs" element={<Blogs />} />
35.	          <Route path="contact" element={<Contact />} />
36.	          <Route path="*" element={<NoPage />} />
37.	        </Route>
38.	      </Routes>
39.	    </BrowserRouter>
40.	  );
  - Line 28: Defines a default export for a React functional component named App.
  - Line 29-39: The App component returns JSX, defining the structure of the application.
  - Line 30: Starts the routing configuration using BrowserRouter from React Router. This component provides the context for routing within the application.
  - Line 31: Introduces the Routes component from React Router. It acts as a container for defining the routes within the application.
  - Line 32: Begins the route configuration with a specific path '/' (the root path) and associates it with a layout component (<Layout />). This layout will be rendered for the root path and will contain nested routes.
  - Line 33-36: Nested Route components within the root route. Each Route specifies a different path and associates it with a particular component to be rendered when that path matches.
  - Line 33: Matches the index route ('/') within the root route and renders the <Home /> component.
  - Line 34: Matches the path '/blogs' within the root route and renders the <Blogs /> component.
  - Line 35: Matches the path '/contact' within the root route and renders the <Contact /> component.
  - Line 36: Matches any other path ('*', a wildcard) within the root route and renders the <NoPage /> component. This is typically used for a 404 or "not found" page.
  - Line 37 through 30 closes everything.

**41.	What role does npm play in web development?**
  - providing a vast ecosystem of packages and tools that developers can use to build, manage, and maintain web applications. Here are the key roles of npm in web development:
  - manage dependencies efficiently by maintaining a package.json file that lists all the dependencies required for a project.
  - enables code reuse by providing a repository of open-source packages
  - run scripts defined in the package.json file, facilitating tasks such as building, testing, linting, bundling, and deployment. It integrates with build tools like Webpack, Babel, and others to automate development workflows.
  - manage package versions, allowing developers to specify version ranges or specific versions for dependencies.
  - npm provides a command-line interface (CLI) that allows developers to perform various package-related tasks, such as installing packages, publishing packages, managing scripts, updating dependencies, and more, making development tasks easier and more efficient.

**42.	What does package.json do in a npm project?**
  - acts as a central configuration file for an npm project, providing information about the project itself, its dependencies, scripts for automation, and other essential metadata required for managing and maintaining the project's development workflow.
  - Metadata: It stores metadata about the project, such as the project name, version, description, author, license, repository URL, and more. This information helps other developers understand the project and its purpose.
  - Dependencies and DevDependencies: It lists the project's dependencies (libraries and packages required for the application to run) and devDependencies (packages necessary for development, such as testing frameworks, build tools, etc.). Each dependency is listed along with its version number or version range.
  - Scripts: It includes scripts that can be executed via npm's command-line interface (CLI). These scripts automate various tasks related to building, testing, running the application, and performing other development-related operations. For example, you might have scripts for starting the server, building the project, running tests, etc.
  - Package Lock File: When dependencies are installed or updated, npm generates a package-lock.json file that locks down the exact version of each dependency installed. This ensures consistency across different environments and prevents unintentional version mismatches.
  - Project Configuration: It can contain custom configurations specific to the project or the tools being used. For instance, configuration settings for ESLint, Babel, Webpack, or any other tools used in the project can be specified here.
  - Project Initialization: package.json is often the starting point when initializing a new project. Running npm init command prompts you to provide details about the project, and it generates a package.json file based on the provided information.

**43.	What does the fetch function do?**
  - make network requests and fetch resources (like JSON data, HTML files, images, etc.) from a specified URL
  - HTTP Requests: It allows making various types of HTTP requests, such as GET, POST, PUT, DELETE, etc., by specifying the request method in the function call.
  - Promise-Based: fetch() returns a Promise that resolves to the Response object representing the response to the request. This allows working with the response data using Promise-based syntax, enabling chaining of .then() and .catch() for handling success or error responses.
  - Asynchronous and Non-Blocking: fetch() operates asynchronously, meaning it doesn’t block the execution of other code while waiting for the response. This is beneficial for web applications to maintain responsiveness.
  - Headers and Request Configuration: It allows configuring the request headers, request body, credentials, and other options through the init parameter. This includes setting headers like Content-Type, Authorization, etc.
  - Cross-Origin Requests: fetch() is subject to the same-origin policy, but it allows making cross-origin requests if the server permits by using CORS (Cross-Origin Resource Sharing). CORS headers need to be set on the server to allow requests from different origins.

**44.	What does node.js do?**
  - Server-Side Execution: Node.js allows developers to execute JavaScript code on the server, enabling the creation of web servers and backend services using JavaScript. It facilitates server-side rendering, handling HTTP requests, and building APIs.
  - Asynchronous, Non-Blocking I/O: Node.js is designed around an event-driven, non-blocking I/O model, allowing it to handle a large number of concurrent connections efficiently. This makes it suitable for building real-time applications like chat applications, gaming servers, and streaming applications.
  - NPM (Node Package Manager): Node.js comes with npm, a robust package manager that hosts a vast ecosystem of open-source libraries and modules. Developers can leverage npm to easily install, manage, and share reusable code packages, making development faster and more efficient.
  - Microservices and APIs: Node.js is well-suited for building microservices and RESTful APIs. Its lightweight and event-driven architecture make it ideal for handling multiple small services or API endpoints efficiently.
  - Full-Stack JavaScript Development: Node.js promotes full-stack JavaScript development by using JavaScript on both the client (browser) and server sides. This unification streamlines the development process and allows for code reuse between frontend and backend.
  - Real-Time Applications: It excels in building real-time applications that require constant communication between the client and server, such as chat applications, online gaming, collaboration tools, and streaming platforms.
  - Community and Ecosystem: Node.js has a vibrant and active community that continuously contributes to its growth. The ecosystem around Node.js includes a wide range of frameworks, tools, and modules to support various development needs.

**45.	What does Vite do?**
  - Vite is a build tool for modern web development that aims to enhance the development experience by providing a faster and more efficient development server and build process. It's specifically designed for building web applications using modern JavaScript frameworks like Vue.js, React, and Svelte.
  - Lightning-Fast Development Server: Vite offers an extremely fast development server that leverages native ES modules (ESM) to serve code directly to the browser without bundling during development. This significantly reduces cold-start build times and speeds up the development workflow.
  - ESM (ES Modules) Support: Vite takes advantage of native ES modules, allowing for direct importing of ES module dependencies in the browser. It supports the use of import and export statements, promoting a more modular code structure.
  - Hot Module Replacement (HMR): Vite provides HMR out of the box, enabling developers to see instant updates in the browser as they edit their code. Changes made to components or modules are reflected in the browser without requiring a full page refresh, improving developer productivity.
  - Optimized Production Build: For production builds, Vite optimizes the output by bundling the code for better performance. It uses Rollup behind the scenes to generate optimized, production-ready bundles with minimal overhead.
  - Framework-Agnostic: While Vite was initially designed for Vue.js, it has evolved to support other frameworks like React, Preact, and Svelte. It provides seamless development experiences for these frameworks while maintaining its performance benefits.
  - Plugin-Based Architecture: Vite's architecture is based on a plugin system, allowing developers to extend and customize its functionality. This enables integration with various tools, preprocessors, and custom workflows.
  - Modern Development Workflow: Vite encourages the use of modern web development features like TypeScript, JSX, CSS preprocessors (like SCSS, Less), and bundling optimizations without complex configuration setups.

**NOTES**
  - URL: https://byu.edu:443/cs/260/student?filter=accepted#summary
  - URL: <scheme>://<domain name>:<port>/<path>?<parameters>#<anchor>
  - HTTP: GET, POST(create), PUT(update), DELETE, OPTIONS
  - SOP and CORS: Same Origin Policy (SOP) was created. Simply stated SOP only allows JavaScript to make requests to a domain if it is the same domain that the user is currently viewing.
  - SOP and CORS: Cross Origin Resource Sharing (CORS) allows the client (e.g. browser) to specify the origin of a request and then let the server respond with what origins are allowed.
  - Service Daemons: When you run a program from the console, the program will automatically terminate when you close the console or if the computer restarts. In order to keep programs running after a shutdown you need to register it as a daemon. The term daemon comes from the idea of something that is always there working in the background.pm2
  - React: React abstracts HTML into a JavaScript variant called JSX. JSX is converted into valid HTML and JavaScript using a preprocessor called Babel. For example, the following is a JSX file. Notice that it mixes both HTML and JavaScript into a single representation.
  - React: React hooks allow React function style components to be able to do everything that a class style component can do and more.
  - function Clicker({initialCount}) {
  const [count, updateCount] = React.useState(initialCount);
  return <div onClick={() => updateCount(count + 1)}>Click count: {count}</div>;
}

ReactDOM.render(<Clicker initialCount={3} />, document.getElementById('root'));
 
  
  
  - function UseEffectHookDemo() {
  React.useEffect(() => {
    console.log('rendered');
  });

  return <div>useEffectExample</div>;
}

ReactDOM.render(<UseEffectHookDemo />, document.getElementById('root'));



- function UseEffectHookDemo() {
  const [count, updateCount] = React.useState(0);
  React.useEffect(() => {
    console.log('rendered');

    return function cleanup() {
      console.log('cleanup');
    };
  });

  return <div onClick={() => updateCount(count + 1)}>useEffectExample {count}</div>;
}

ReactDOM.render(<UseEffectHookDemo />, document.getElementById('root'));


- You can control what triggers a useEffect hook by specifying its dependencies. In the following example we have two state variables, but we only want the useEffect hook to be called when the component is initially called and when the first variable is clicked. To accomplish this you pass an array of dependencies as a second parameter to the useEffect call.

- function UseEffectHookDemo() {
  const [count1, updateCount1] = React.useState(0);
  const [count2, updateCount2] = React.useState(0);

  React.useEffect(() => {
    console.log(`count1 effect triggered ${count1}`);
  }, [count1]);

  return (
    <ol>
      <li onClick={() => updateCount1(count1 + 1)}>Item 1 - {count1}</li>
      <li onClick={() => updateCount2(count2 + 1)}>Item 2 - {count2}</li>
    </ol>
  );
}

ReactDOM.render(<UseEffectHookDemo />, document.getElementById('root'));

- If you specify and empty array [] as the hook dependency then it is only called when the component is first rendered.


React: Vite bundles your code quickly, has great debugging support, and allows you to easily support JSX, TypeScript, and different CSS flavors. 


